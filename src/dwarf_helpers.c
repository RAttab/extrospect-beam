#include <err.h>
#include <string.h>
#include <unistd.h>

#include <dwarf.h>

#include "dwarf_helpers.h"
#include "remote.h"

static int find_elf (Dwfl_Module *m, void **up,
                     const char *mname, Dwarf_Addr addr,
                     char **pathp, Elf **elfp)
{
    int rv = dwfl_build_id_find_elf(m, up, mname, addr, pathp, elfp);
    if (rv != -1) return rv;
    rv = dwfl_linux_kernel_find_elf(m, up, mname, addr, pathp, elfp);
    if (rv != -1) return rv;
    /* XXX This is broken; we have to write this one ourselves.  First
     * of all, it could ptrace which we definitely don't want.  Second
     * of all, it doesn't even read /proc/PID/maps correctly. */
    return dwfl_linux_proc_find_elf(m, up, mname, addr, pathp, elfp);
}


Dwfl *dwarf_helpers_get_dwfl(pid_t pid)
{
    static char *debuginfo_path;
    static const Dwfl_Callbacks proc_callbacks = {
        .find_debuginfo = dwfl_standard_find_debuginfo,
        .debuginfo_path = &debuginfo_path,
        .find_elf = find_elf,
        .section_address = dwfl_linux_kernel_module_section_address,
    };
    Dwfl *dwfl = dwfl_begin(&proc_callbacks);
    if (dwfl == NULL)
        errx(2, "dwfl_begin: %s", dwfl_errmsg(-1));
    if (0 != dwfl_linux_proc_report(dwfl, pid))
        errx(1, "dwfl_linux_proc_report: %s", dwfl_errmsg(-1));
    if (0 != dwfl_linux_kernel_report_kernel(dwfl))
        errx(1, "dwfl_linux_kernel_report_kernel: %s", dwfl_errmsg(-1));
    if (0 != dwfl_linux_kernel_report_modules(dwfl))
        errx(1, "dwfl_linux_kernel_report_modules: %s", dwfl_errmsg(-1));

    if (0 != dwfl_report_end(dwfl, NULL, NULL))
        errx(1, "dwfl_report_end: %s", dwfl_errmsg(-1));

    return dwfl;
}


struct fmms_ctx { const char *substr; Dwfl_Module *module; };

static int fmms_helper(Dwfl_Module *module,
                       void **_ __attribute__((unused)),
                       const char *name,
                       Dwarf_Addr _start __attribute__((unused)),
                       void *ctx_)
{
    struct fmms_ctx *ctx = ctx_;
    if (strstr(name, ctx->substr)) {
        ctx->module = module;
        return DWARF_CB_ABORT;
    }
    return DWARF_CB_OK;
}

Dwfl_Module *dwarf_helpers_find_module_matching_substring(Dwfl *dwfl, const char *substr)
{
    struct fmms_ctx ctx = {.substr = substr};
    dwfl_getmodules(dwfl, fmms_helper, &ctx, 0);
    return ctx.module;
}

/* So, the DWARF standard documents .debug_pubnames as a way to
 * quickly look things up by name.  However as discussed in gcc bug
 * 50497 <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=50497>, gcc -g
 * no longer produces debug_pubnames because "gdb doesn't use it".
 *
 * It turns out you can produce it these days by specifying -gpubnames
 * but I'd like this to work without too many special compiler flags.
 */

/* We may need a separate one for PC values, since they might not be
 * in our module. */
bool dwarf_helpers_info_address(Dwfl_Module *module, const char *symbol, uintptr_t *addr, size_t *size)
{
    int n_syms = dwfl_module_getsymtab(module);
    GElf_Sym sym;
    GElf_Word section_index_p;
    for (int i = 0; i < n_syms; ++i) {
        const char *name =
            dwfl_module_getsym(module, i, &sym, &section_index_p);
        if (name && 0 == strcmp(name, symbol)) {
            if (size)
                *size = sym.st_size;
            if (addr)
                *addr = sym.st_value;
            return true;
        }
    }
    return false;
}


uintptr_t dwarf_helpers_info_address_or_die(Dwfl_Module *module, const char *symbol, size_t expected_size)
{
    uintptr_t addr;
    size_t size;
    if (!dwarf_helpers_info_address(module, symbol, &addr, &size))
        errx(1, "dwarf_helpers_info_address_or_die: can't find symbol '%s'", symbol);
    if (size != expected_size)
        errx(1, "dwarf_helpers_info_address_or_die: expected size (%zu) didn't match actual (%zu) for symbol '%s'",
             expected_size, size, symbol);
    return addr;
}


static const char *string_of_dw_tag(int tag)
{
    /* Generated by emacs macro from enum in dwarf.h */
    switch (tag) {
    case DW_TAG_array_type: return "array_type";
    case DW_TAG_class_type: return "class_type";
    case DW_TAG_entry_point: return "entry_point";
    case DW_TAG_enumeration_type: return "enumeration_type";
    case DW_TAG_formal_parameter: return "formal_parameter";
    case DW_TAG_imported_declaration: return "imported_declaration";
    case DW_TAG_label: return "label";
    case DW_TAG_lexical_block: return "lexical_block";
    case DW_TAG_member: return "member";
    case DW_TAG_pointer_type: return "pointer_type";
    case DW_TAG_reference_type: return "reference_type";
    case DW_TAG_compile_unit: return "compile_unit";
    case DW_TAG_string_type: return "string_type";
    case DW_TAG_structure_type: return "structure_type";
    case DW_TAG_subroutine_type: return "subroutine_type";
    case DW_TAG_typedef: return "typedef";
    case DW_TAG_union_type: return "union_type";
    case DW_TAG_unspecified_parameters: return "unspecified_parameters";
    case DW_TAG_variant: return "variant";
    case DW_TAG_common_block: return "common_block";
    case DW_TAG_common_inclusion: return "common_inclusion";
    case DW_TAG_inheritance: return "inheritance";
    case DW_TAG_inlined_subroutine: return "inlined_subroutine";
    case DW_TAG_module: return "module";
    case DW_TAG_ptr_to_member_type: return "ptr_to_member_type";
    case DW_TAG_set_type: return "set_type";
    case DW_TAG_subrange_type: return "subrange_type";
    case DW_TAG_with_stmt: return "with_stmt";
    case DW_TAG_access_declaration: return "access_declaration";
    case DW_TAG_base_type: return "base_type";
    case DW_TAG_catch_block: return "catch_block";
    case DW_TAG_const_type: return "const_type";
    case DW_TAG_constant: return "constant";
    case DW_TAG_enumerator: return "enumerator";
    case DW_TAG_file_type: return "file_type";
    case DW_TAG_friend: return "friend";
    case DW_TAG_namelist: return "namelist";
    case DW_TAG_namelist_item: return "namelist_item";
    case DW_TAG_packed_type: return "packed_type";
    case DW_TAG_subprogram: return "subprogram";
    case DW_TAG_template_type_parameter: return "template_type_parameter";
    case DW_TAG_template_value_parameter: return "template_value_parameter";
    case DW_TAG_thrown_type: return "thrown_type";
    case DW_TAG_try_block: return "try_block";
    case DW_TAG_variant_part: return "variant_part";
    case DW_TAG_variable: return "variable";
    case DW_TAG_volatile_type: return "volatile_type";
    case DW_TAG_dwarf_procedure: return "dwarf_procedure";
    case DW_TAG_restrict_type: return "restrict_type";
    case DW_TAG_interface_type: return "interface_type";
    case DW_TAG_namespace: return "namespace";
    case DW_TAG_imported_module: return "imported_module";
    case DW_TAG_unspecified_type: return "unspecified_type";
    case DW_TAG_partial_unit: return "partial_unit";
    case DW_TAG_imported_unit: return "imported_unit";
    /* 0x3e reserved.  */
    case DW_TAG_condition: return "condition";
    case DW_TAG_shared_type: return "shared_type";
    case DW_TAG_type_unit: return "type_unit";
    case DW_TAG_rvalue_reference_type: return "rvalue_reference_type";
    case DW_TAG_template_alias: return "template_alias";

    /* DWARF 5.  */
    case DW_TAG_atomic_type: return "atomic_type";

    case DW_TAG_lo_user: return "lo_user";

    case DW_TAG_MIPS_loop: return "MIPS_loop";
    case DW_TAG_format_label: return "format_label";
    case DW_TAG_function_template: return "function_template";
    case DW_TAG_class_template: return "class_template";

    case DW_TAG_GNU_BINCL: return "GNU_BINCL";
    case DW_TAG_GNU_EINCL: return "GNU_EINCL";

    case DW_TAG_GNU_template_template_param: return "GNU_template_template_param";
    case DW_TAG_GNU_template_parameter_pack: return "GNU_template_parameter_pack";
    case DW_TAG_GNU_formal_parameter_pack: return "GNU_formal_parameter_pack";
    case DW_TAG_GNU_call_site: return "GNU_call_site";
    case DW_TAG_GNU_call_site_parameter: return "GNU_call_site_parameter";
    default: return "(unknown)";
    }
}


/* XXX do I need dwarf_dealloc everywhere?  Looks like dwfl_end()
 * will deallocate all these things, but they are allocations, so
 * if you're doing this a lot, you might want to deallocate these
 * DIEs as you no longer need them. */
void dwarf_helpers_dump_die(Dwarf_Die *p, int depth)
{
    if (!p) return;
    const char *name = dwarf_diename(p);
    printf("%*c%s %s\n", 2*depth, ' ',
           string_of_dw_tag(dwarf_tag(p)),
           dwarf_diename(p));
    if (name && 0 == strcmp(name, "process_main")) {
        printf("%*c%d %s\n", 2*depth, ' ', dwarf_tag(p), dwarf_diename(p));
    }
    Dwarf_Die q;

    if (dwarf_haschildren(p) && 0 == dwarf_child(p, &q))
        dwarf_helpers_dump_die(&q, 1+depth);

    if (0 == dwarf_siblingof(p, &q) && q.addr) {
        p = &q;
        dwarf_helpers_dump_die(p, depth);
    }
}


/* Find the first occurrance of a symbol with a given name and tag, in
 * any CU within the specified module. */
bool dwarf_helpers_find_toplevel_symbol(Dwfl_Module *module, Dwarf_Die *result, const char *name, int tag)
{
    Dwarf_Die *cu = NULL;
    Dwarf_Addr dwarf_bias;
    while (NULL != (cu = dwfl_module_nextcu (module, cu, &dwarf_bias))) {
        if (!dwarf_haschildren(cu))
            continue;
        if (0 != dwarf_child(cu, result))
            return false;
        do {
            if (dwarf_tag(result) == tag) {
                const char *candidate_name = dwarf_diename(result);
                if (candidate_name && 0 == strcmp(name, candidate_name))
                    return true;
            }
        } while (0 == dwarf_siblingof(result, result));
    }
    return false;
}


bool dwarf_helpers_find_peeled_type(Dwfl_Module *module, const char *symbol, Dwarf_Die *result)
{
    Dwarf_Die *cu = NULL;
    Dwarf_Addr dwarf_bias;
    while (NULL != (cu = dwfl_module_nextcu (module, cu, &dwarf_bias))) {
        if (!dwarf_haschildren(cu))
            continue;
        if (0 != dwarf_child(cu, result))
            return false;
        do {
            int tag = dwarf_tag(result);
            if (DW_TAG_structure_type != tag &&
                !dwarf_hasattr(result, DW_AT_type))
                continue;
            const char *candidate_name = dwarf_diename(result);
            if (!candidate_name || 0 != strcmp(symbol, candidate_name))
                continue;
            if (DW_TAG_structure_type == tag)
                return true;

            Dwarf_Attribute attr;
            if (dwarf_hasattr(result, DW_AT_type) &&
                (NULL == dwarf_attr(result, DW_AT_type, &attr) ||
                 NULL == dwarf_formref_die(&attr, result))) {
                warnx("ugh, tried to read DW_AT_type but failed: %s", dwarf_errmsg(-1));
                return false;
            }

            if (-1 == dwarf_peel_type(result, result)) {
                warnx("dwarf_peel_type: %s", dwarf_errmsg(-1));
                /* XXX should probably return false here */
                continue;
            }
            candidate_name = dwarf_diename(result);
            tag = dwarf_tag(result);
            return true;
        } while (0 == dwarf_siblingof(result, result));
    }
    return false;
}


ssize_t dwarf_helpers_offset_of(Dwarf_Die *structure, const char *member)
{
    Dwarf_Die child;
    if (!dwarf_haschildren(structure)) {
        warnx("dwarf_helpers_offset_of: passed a DIE without children");
        return -1;
    }
    if (0 != dwarf_child(structure, &child)) {
        warnx("dwarf_child: %s", dwarf_errmsg(-1));
        return -1;
    }
    do {
        const char *diename = dwarf_diename(&child);
        if (!diename || 0 != strcmp(diename, member))
            continue;
        if (!dwarf_hasattr(&child, DW_AT_data_member_location)) {
            warnx("dwarf_helpers_offset_of: member '%s' doesn't have DW_AT_data_member_location!", member);
            return -1;
        }
        Dwarf_Attribute attr;
        if (NULL == dwarf_attr(&child, DW_AT_data_member_location, &attr)) {
            warnx("dwarf_attr: %s", dwarf_errmsg(-1));
            return -1;
        }
        Dwarf_Word offset;
        Dwarf_Block block = {0};
        switch (dwarf_whatform(&attr)) {
        case DW_FORM_data1:
        case DW_FORM_data2:
        case DW_FORM_data4:
        case DW_FORM_data8:
        case DW_FORM_udata:
            if (0 != dwarf_formudata(&attr, &offset)) {
                warnx("dwarf_formudata: %s", dwarf_errmsg(-1));
                return -1;
            }
            return offset;
        case DW_FORM_block:
        case DW_FORM_block1:
        case DW_FORM_block2:
        case DW_FORM_block4:
            if (0 != dwarf_formblock(&attr, &block)) {
                warnx("dwarf_formblock: %s", dwarf_errmsg(-1));
                return -1;
            }

            /* XXX wtf dwarf. */
            if (block.length != 2) {
                warnx("dwarf_helpers_offset_of: got a block length of %lu, backing out", block.length);
                return -1;
            }
            if (block.data[0] != DW_OP_addr &&
                block.data[0] != DW_OP_plus_uconst) {
                warnx("dwarf_helpers_offset_of: not even bothering to handle bullshit DWARF OP %d", block.data[0]);
                return -1;
            }
            return block.data[1];
        default:
            warnx("no idea how to decode form %d", dwarf_whatform(&attr));
            return -1;
        }
    } while (0 == dwarf_siblingof(&child, &child));
    return -1;
}


/* Graveyard: */
#if 0
    Elf_Scn *section = NULL;
    while (NULL != (section = elf_nextscn(elf, section))) {
        GElf_Shdr section_header;
        if (NULL == gelf_getshdr(section, &section_header))
            errx(1, "gelf_getshdr: %s", elf_errmsg(-1));
        if (section_header.sh_type != SHT_SYMTAB)
            continue;
        /* XXX we should(?) handle an extended section index table
         * here but I have no fucking idea about that */

        size_t n_sections;
        ENSURE_ELF(elf_getshdrnum, elf, &n_sections);
        size_t section_header_string_table_idx;
        ENSURE_ELF(elf_getshdrstrndx, elf, &section_header_string_table_idx);
        size_t n_entries = section_header.sh_size / section_header.sh_entsize;
        printf("%s has %zu entries\n",
               elf_strptr(elf, section_header_string_table_idx, section_header.sh_name),
               n_entries);
        Elf_Data *data = elf_getdata(section, NULL);
        if (NULL == data)
            errx(1, "elf_getdata: %s", elf_errmsg(-1));

        for (size_t i = 0; i < n_entries; ++i) {
            GElf_Sym *sym = gelf_getsymshndx(data, NULL, i, NULL, NULL);
            printf("%zu: %d %lx %zu\n", i, sym->st_name, sym->st_value, sym->st_size);
        }
    }

    Dwarf_Die die;
    if (dwarf_helpers_find_toplevel_symbol(module, &die, "the_active_code_index", DW_TAG_variable)) {
        /* if (!dwarf_hasattr(&die, DW_AT_location)) */
        /*     errx(1, "wtf, the_active_code_index doesn't have DW_AT_location"); */
        /* Dwarf_Attribute attr; */
        /* if (0 != dwarf_attr(&die, DW_AT_location, &attr)) */
        /*     errx(1, "dwarf_attr: %s", dwarf_errmsg(-1)); */
        /* if (!dwarf_hasform(&attr, DW_FORM_addr)) */
        /*     errx(1, "the_active_code_index isn't in 'addr' form: %d", dwarf_whatform(&attr)); */

          Dwarf_Attribute locattr_mem;
          Dwarf_Attribute *locattr = dwarf_attr (&die, DW_AT_location, &locattr_mem);
          if  (locattr == NULL)
              errx(1, "foo");

          Dwarf_Op *loc;
          size_t nloc;
          if (dwarf_getlocation (locattr, &loc, &nloc) != 0)
              errx(1, "bar");

        /* printf("%s: %s\n", dwarf_diename(&die), dwarf_formstring(&attr)); */
    }


#endif

#include <asm/perf_regs.h>


struct perf_reg_of_dwarf_reg_ctx {
    uint8_t in;
    uint64_t out;
};

/* from asm/perf_regs.h and elfutils/backends/x86_64_initreg.c, but
 * mostly maps to figure 3.36 in the x86-64 ELF ABI spec */
uint64_t dwarf_reg_of_perf_reg[PERF_REG_X86_64_MAX] = {
    [PERF_REG_X86_AX] = 0,
    [PERF_REG_X86_BX] = 3,
    [PERF_REG_X86_CX] = 2,
    [PERF_REG_X86_DX] = 1,
    [PERF_REG_X86_SI] = 4,
    [PERF_REG_X86_DI] = 5,
    [PERF_REG_X86_BP] = 6,
    [PERF_REG_X86_SP] = 7,
    [PERF_REG_X86_R8] = 8,
    [PERF_REG_X86_R9] = 9,
    [PERF_REG_X86_R10] = 10,
    [PERF_REG_X86_R11] = 11,
    [PERF_REG_X86_R12] = 12,
    [PERF_REG_X86_R13] = 13,
    [PERF_REG_X86_R14] = 14,
    [PERF_REG_X86_R15] = 15,
    [PERF_REG_X86_IP] = 16,
};
uint64_t valid_perf_dwarf_regs =
    (1<<PERF_REG_X86_AX)|
    (1<<PERF_REG_X86_BX)|
    (1<<PERF_REG_X86_CX)|
    (1<<PERF_REG_X86_DX)|
    (1<<PERF_REG_X86_SI)|
    (1<<PERF_REG_X86_DI)|
    (1<<PERF_REG_X86_BP)|
    (1<<PERF_REG_X86_SP)|
    (1<<PERF_REG_X86_R8)|
    (1<<PERF_REG_X86_R9)|
    (1<<PERF_REG_X86_R10)|
    (1<<PERF_REG_X86_R11)|
    (1<<PERF_REG_X86_R12)|
    (1<<PERF_REG_X86_R13)|
    (1<<PERF_REG_X86_R14)|
    (1<<PERF_REG_X86_R15)|
    (1<<PERF_REG_X86_IP);
_Static_assert(PERF_REG_X86_64_MAX < 8*sizeof(valid_perf_dwarf_regs), "bitmap too small");

/* generated from asm/perf_regs.h */
static const char *perf_reg_map[PERF_REG_X86_64_MAX] = {
    [PERF_REG_X86_AX] = "rax",
    [PERF_REG_X86_BX] = "rbx",
    [PERF_REG_X86_CX] = "rcx",
    [PERF_REG_X86_DX] = "rdx",
    [PERF_REG_X86_SI] = "rsi",
    [PERF_REG_X86_DI] = "rdi",
    [PERF_REG_X86_BP] = "rbp",
    [PERF_REG_X86_SP] = "rsp",
    [PERF_REG_X86_IP] = "rip",
    [PERF_REG_X86_FLAGS] = "rflags",
    [PERF_REG_X86_CS] = "cs",
    [PERF_REG_X86_SS] = "ss",
    [PERF_REG_X86_DS] = "ds",
    [PERF_REG_X86_ES] = "es",
    [PERF_REG_X86_FS] = "fs",
    [PERF_REG_X86_GS] = "gs",
    [PERF_REG_X86_R8] = "r8",
    [PERF_REG_X86_R9] = "r9",
    [PERF_REG_X86_R10] = "r10",
    [PERF_REG_X86_R11] = "r11",
    [PERF_REG_X86_R12] = "r12",
    [PERF_REG_X86_R13] = "r13",
    [PERF_REG_X86_R14] = "r14",
    [PERF_REG_X86_R15] = "r15"
};


int perf_reg_of_string(const char *s)
{
    for (size_t i = 0; i < PERF_REG_X86_64_MAX; ++i)
        if (0 == strcmp(perf_reg_map[i], s))
            return i;
    return -1;
}


static int
find_matching_register(void *ctx_, int regno, const char *UNUSED,
                       const char *UNUSED, const char *regname, int UNUSED,
                       int UNUSED)
{
    struct perf_reg_of_dwarf_reg_ctx *ctx = ctx_;
    if (regno != ctx->in)
        return DWARF_CB_OK;
    for (size_t i = 0; i < PERF_REG_X86_64_MAX; ++i)
        if (0 == strcmp(perf_reg_map[i], regname)) {
            printf("found %s\n", regname);
            ctx->out = i;
            return DWARF_CB_ABORT;
        }

    errx(1, "tried to find %s but it's not sampleable by perf.", regname);
}

static uint64_t perf_reg_of_dwarf_reg(Dwfl_Module *dwarf_module, uint8_t reg)
{
    struct perf_reg_of_dwarf_reg_ctx ctx = { .in = reg };
    /* XXX consider instead doing something like
       dwfl_module_register_names(dwarf_module, setup_dwarf_perf_register_map, map);
       at the beginning of the program, populating an array of
       PERF_REG_X86_64_MAX ints. */
    if (dwfl_module_register_names(dwarf_module, find_matching_register, &ctx) < 0)
        errx(1, "dwfl_module_register_names: %s", dwarf_errmsg(-1));
    return ctx.out;
}


bool
dwarf_helpers_find_register_for(uint64_t *out, Dwfl_Module *module,
                                Dwarf_Die *die, const char *target)
{
    Dwarf_Die child;
    dwarf_child(die, &child);
    do {
        if (DW_TAG_variable != dwarf_tag(&child))
            continue;
        const char *name = dwarf_diename(&child);
        if (!name || strcmp(name, target))
            continue;

        if (!dwarf_hasattr(&child, DW_AT_location))
            return false;

        Dwarf_Attribute attr;
        if (NULL == dwarf_attr(&child, DW_AT_location, &attr))
            errx(1, "dwarf_attr: %s", dwarf_errmsg(-1));

        switch (dwarf_whatform(&attr)) {
        case DW_FORM_block1:
        {
            Dwarf_Block block;
            ENSURE_DWARF(dwarf_formblock, &attr, &block);
            if (block.data[0] < DW_OP_reg0 ||
                block.data[0] > DW_OP_breg31)
                errx(1, "block: expected register op, got 0x%x", block.data[0]);
            if (out)
                *out = perf_reg_of_dwarf_reg(module,
                                             block.data[0] - DW_OP_reg0);
            return true;
        }

        default:
            warnx("(while looking for the register for %s): Not sure how to interpret DWARF FORM type 0x%x",
                  target, dwarf_whatform(&attr));
            return false;
        }
    } while (0 == dwarf_siblingof(&child, &child));
    return false;
}
